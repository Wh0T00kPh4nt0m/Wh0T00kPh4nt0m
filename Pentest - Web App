Now we’re in the human layer of the stack — where computers do exactly what we tell them, and websites do exactly what nobody *meant* them to do. Web app testing is less about volume and more about **attention**.

Below are **practical, muscle-memory commands and workflows**, not tool worship.

---

## Burp Suite (Your Web App Time Machine)

**Launch Burp (community is enough for skill-building):**

```bash
burpsuite
```

**Set browser proxy:**

```
127.0.0.1 : 8080
```

**Key moves you should internalize:**

* Proxy → Intercept ON when logging in
* Send requests to **Repeater** to mutate them
* Use **Intruder** sparingly (precision beats noise)

**Typical auth test (in Repeater):**

* Change `user_id=102` → `user_id=103`
* Change `role=user` → `role=admin`
* Remove cookies or JWT entirely and resend

Burp isn’t a scanner. It’s a microscope.

---

## ffuf (Fast, Clean, Brutally Honest)

**Directory fuzzing:**

```bash
ffuf -u https://example.com/FUZZ -w directories.txt -mc 200
```

**Ignore common junk responses:**

```bash
ffuf -u https://example.com/FUZZ -w directories.txt -fc 403,404
```

**File extension discovery:**

```bash
ffuf -u https://example.com/FUZZ -w files.txt -e .php,.bak,.old,.txt
```

**Parameter fuzzing:**

```bash
ffuf -u "https://example.com/index.php?FUZZ=test" -w params.txt
```

**Fuzz POST data:**

```bash
ffuf -u https://example.com/login -X POST -d "username=admin&password=FUZZ" -w passwords.txt
```

---

## wfuzz (More Flexible, Slightly More Feral)

**Basic directory fuzzing:**

```bash
wfuzz -c -z file,dirs.txt --hc 404 https://example.com/FUZZ
```

**POST brute force:**

```bash
wfuzz -c -z file,passwords.txt -d "user=admin&pass=FUZZ" https://example.com/login
```

**Header fuzzing:**

```bash
wfuzz -c -z file,headers.txt -H "X-Forwarded-For: FUZZ" https://example.com
```

wfuzz shines when you need *surgical weirdness*.

---

## Nikto (Old Dog, Sharp Nose)

**Standard scan:**

```bash
nikto -h https://example.com
```

**Scan specific port:**

```bash
nikto -h example.com -p 8080
```

**Save output:**

```bash
nikto -h example.com -o nikto.txt
```

Nikto finds **low-hanging fruit**, forgotten panels, outdated software. Treat findings as leads, not verdicts.

---

## Manual Testing (Where Real Bugs Come From)

This is the part no tool can automate.

**Authentication:**

* Log in → log out → reuse old cookies
* Change `user_id` values
* Test password reset tokens twice

**Authorization / Roles:**

* Access `/admin` as a normal user
* Change role flags in requests
* Compare responses between accounts

**Business Logic:**

* Buy negative quantities
* Skip steps in multi-stage flows
* Reuse discount codes
* Replay requests out of order

**Input Handling:**

* Remove parameters entirely
* Send unexpected types (`null`, arrays, long strings)
* Change `POST` → `GET`

Manual testing is where you stop thinking like a hacker and start thinking like a **lazy developer under deadline pressure**.

---

## The Quiet Truth About Web App Testing

Automated tools find bugs.
Manual testing finds **stories**.

Every vulnerability is a misunderstanding frozen into code. Your job is to gently misunderstand it back.

From here, the natural progression is:

* chaining web bugs → foothold
* foothold → internal enumeration
* internal access → privilege escalation

That’s not hacking. That’s systems thinking wearing a hoodie.
